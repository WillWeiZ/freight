# 司机送货成本分析系统 - 完整实施计划

## 项目概述

构建一个基于司机GPS打卡数据的送货成本分析系统，通过高德API计算真实行驶距离，实现精准的配送成本核算。

## 第一步：数据处理与成本计算核心功能

### 1.1 数据预处理模块

- **CSV数据读取与清洗**
  - 处理缺失值和异常GPS坐标
  - 时间格式标准化
  - 数据类型转换和验证

### 1.2 司机轨迹分析模块（详细设计）

#### 输入数据结构

| 字段名 | 数据类型 | 说明 | 示例 |
|--------|----------|------|------|
| 微信open_id | String | 司机唯一标识 | oueuz7azmmFb7R0JOZVaTFKsa2zg |
| 提交时间 | DateTime | GPS打卡时间 | 2025-09-15 10:35:53 |
| 经度 | Float | 打卡位置经度 | 112.54299207899305 |
| 纬度 | Float | 打卡位置纬度 | 26.908761935763888 |

#### 计算逻辑设计

**起点识别算法权重表：**

| 识别方法 | 判断条件 | 权重 | 说明 |
|----------|----------|------|------|
| 时间分析法 | 当日首次打卡位置 | 40% | 假设司机从仓库开始配送 |
| 频率分析法 | 多日重复出现的起始位置 | 35% | 统计分析找出仓库位置 |
| 地址关键词 | 包含"仓库"、"物流"、"配送中心" | 15% | 基于地址描述识别 |
| 坐标聚类 | GPS坐标密集区域 | 10% | 聚类分析找出集中点 |

**路径链构建流程：**

| 序号 | 处理步骤 | 输入 | 输出 | 算法 |
|------|----------|------|------|------|
| 1 | 起点设定 | 司机当日数据 | 配送起点坐标 | 起点识别算法 |
| 2 | 时间排序 | 当日所有打卡记录 | 按时间排序的坐标序列 | 时间戳排序 |
| 3 | 路径去重 | 排序后坐标序列 | 去除重复位置的有效路径 | 坐标距离阈值过滤 |
| 4 | 异常检测 | 有效路径 | 标记异常路径点 | 速度/距离异常检测 |
| 5 | 路径补全 | 异常处理后路径 | 完整配送路径链 | 路径插值算法 |

#### 输出数据结构

**主输出表：司机日配送路径表**

| 字段名 | 数据类型 | 说明 | 示例 |
|--------|----------|------|------|
| 司机ID | String | 微信open_id | oueuz7azmmFb7R0JOZVaTFKsa2zg |
| 配送日期 | Date | 配送日期 | 2025-09-15 |
| 起点坐标 | Tuple | (经度,纬度) | (112.543, 26.909) |
| 路径序列 | List | 按时间排序的坐标点列表 | [(112.543,26.909), (112.567,26.892)...] |
| 配送点数量 | Integer | 当日配送门店数量 | 8 |
| 总配送时长 | Integer | 分钟数 | 480 |
| 路径状态 | String | 完整/异常/不完整 | 完整 |

### 1.3 高德API集成模块

- **路径规划API调用**
  - 驾车路径规划
  - 批量路径计算优化
  - API调用失败重试机制
- **距离数据获取与缓存**

### 1.4 成本计算引擎

#### 参数配置表

| 参数类别 | 参数名称 | 数据类型 | 默认值 | 说明 |
|----------|----------|----------|--------|------|
| 可变参数 | 油费单价 | Float | 7.5 | 元/升 |
| 可变参数 | 过路费率 | Float | 0.45 | 元/公里 |
| 可变参数 | 百公里油耗 | Float | 8.0 | 升/100公里 |
| 固定参数 | 车辆折旧 | Float | 150.0 | 元/天 |
| 固定参数 | 保险费用 | Float | 50.0 | 元/天 |
| 固定参数 | 司机工资 | Float | 200.0 | 元/天 |
| 收集参数 | GPS轨迹 | List | - | 坐标序列 |
| 收集参数 | 配送时长 | Integer | - | 分钟 |

#### 成本计算公式

```text
总配送成本 = 里程成本 + 时间成本 + 固定成本

里程成本 = 实际行驶距离 × (油费单价 × 百公里油耗 / 100 + 过路费率)
时间成本 = 配送时长 × 司机时薪
固定成本 = 车辆折旧 + 保险费用 + 其他固定开支
```

### 1.5 结果输出表格设计

#### 司机维度统计表

| 字段名 | 说明 |
|--------|------|
| 司机ID | 微信open_id |
| 配送日期 | 统计日期 |
| 总里程数 | 公里 |
| 总配送时长 | 小时 |
| 配送门店数 | 个数 |
| 里程成本 | 元 |
| 时间成本 | 元 |
| 固定成本 | 元 |
| 总成本 | 元 |
| 平均单店成本 | 元/店 |

## 第二步：Streamlit可视化部署

### 2.1 Web应用架构

- **主页面：数据上传与参数配置**
- **分析页面：司机轨迹分析结果**
- **可视化页面：Folium地图展示**
- **报表页面：成本统计表格**

### 2.2 Folium地图功能

- **司机路径轨迹展示（彩色线条）**
- **门店位置标记（图标标注）**
- **成本热力图显示**
- **交互式控件（时间筛选、司机筛选）**

## 第三步：React全栈重构

### 3.1 前端React应用

- **现代化Material-UI组件**
- **响应式地图界面（Leaflet集成）**
- **实时数据更新机制**
- **用户权限管理**

### 3.2 后端API服务

- **FastAPI RESTful接口**
- **PostgreSQL数据库集成**
- **Redis缓存优化**
- **JWT认证机制**

## 技术栈与依赖

### 第一步核心依赖

```text
pandas>=1.5.0
numpy>=1.21.0
requests>=2.28.0
python-dotenv>=0.19.0
geopy>=2.2.0
scikit-learn>=1.1.0
```

### 第二步可视化依赖

```text
streamlit>=1.25.0
folium>=0.14.0
plotly>=5.15.0
altair>=4.2.0
```

### 第三步全栈依赖

```text
# 后端
fastapi>=0.100.0
uvicorn>=0.22.0
sqlalchemy>=2.0.0
alembic>=1.11.0

# 前端
react>=18.2.0
@mui/material>=5.14.0
react-leaflet>=4.2.0
axios>=1.4.0
```

## 实施时间规划

- **第一步：2-3周（核心功能开发）**
- **第二步：1-2周（可视化部署）**
- **第三步：3-4周（全栈重构）**

## 核心算法伪代码

### 起点识别算法

```python
def identify_depot_location(driver_data):
    # 1. 时间分析：每日首次打卡位置
    daily_first_locations = []

    # 2. 频率分析：重复出现的起始位置
    location_frequency = {}

    # 3. 地址关键词匹配
    depot_keywords = ['仓库', '物流', '配送中心', '分拣']

    # 4. 坐标聚类分析
    coordinates = [(lat, lon) for lat, lon in zip(lats, lons)]
    clusters = DBSCAN(eps=0.001, min_samples=3).fit(coordinates)

    # 综合评分确定最终起点
    return weighted_depot_location
```

### 路径异常检测算法

```python
def detect_path_anomalies(path_sequence, time_sequence):
    anomalies = []

    for i in range(1, len(path_sequence)):
        # 计算相邻点距离和时间差
        distance = calculate_distance(path_sequence[i-1], path_sequence[i])
        time_diff = time_sequence[i] - time_sequence[i-1]

        # 异常检测规则
        if distance > 100:  # 距离超过100公里
            anomalies.append({'type': '距离异常', 'index': i})
        if time_diff < 5:   # 时间间隔小于5分钟但距离很远
            anomalies.append({'type': '时间异常', 'index': i})

    return anomalies
```

### 性能优化策略

| 优化点 | 策略 | 预期效果 |
|--------|------|----------|
| 数据加载 | 分块读取大文件 | 减少内存占用 |
| 坐标计算 | 向量化运算 | 提升计算速度 |
| 聚类算法 | 使用KD-Tree加速 | 减少时间复杂度 |
| 缓存机制 | 缓存重复计算结果 | 避免重复计算 |